//==============================================
// Name:           Davinder Verma
// Student Number: 121802201
// Email:          dverma22@myseneca.ca
// Section:        NAA
// Workshop:       8 
// Date:           25/03/2021
//==============================================

I learnt about raw and smart pointers of the memory library in this workshop. At first, I was not getting
the code files provided so I refered the ICT notes thoroughly. Smart pointers are able to manage the memory that it points too.
so for example, the mergeSmart is used as smart pointer. So, as we create a newly dynamically allocation. As the pointer is going
out off scope it will desctruct itself and will also destory the dynamic memory. Due to this automatic deallocation the 
memory leaks are avoided.

As used in the workshop:
	List<Product> mergeSmart(const List<Description>& desc, const List<Price>& price) {
		List<Product> priceList;
		
		// TODO: Add your code here to build a list of products
		//         using smart pointers
		
		for (int i = 0; i < desc.size(); i++)
		{
			for (int j = 0; j < price.size(); j++)
			{
				if (desc[i].code == price[j].code)
				{
					std::unique_ptr<Product> temp(new Product(desc[i].desc, price[j].price));
					temp->validate();
					priceList += move(temp);
				}
			}
		}

		return priceList;
	}
	
The main difference between the raw and smart pointer is that smart pointers delete the dynamically allocated memory on their own
whereas if we use the raw pointers we have to delete the memory on our own. So if we use smart pointers the memory leaks will be 
avoided.